---
title: POJ3009 题解
description: POJ3009 题解
slug: POJ3009 题解
authors:
  - andrew
tags: [ACM, Algorithm, DFS, Search]
hide_table_of_contents: false
---

<!-- truncate -->

## 原题

[Curling 2.0](https://vjudge.net/problem/POJ-3009)

On Planet MM-21, after their Olympic games this year, curling is getting popular. But the rules are somewhat different from ours. The game is played on an ice game board on which a square mesh is marked. They use only a single stone. The purpose of the game is to lead the stone from the start to the goal with the minimum number of moves.

Fig. 1 shows an example of a game board. Some squares may be occupied with blocks. There are two special squares namely the start and the goal, which are not occupied with blocks. (These two squares are distinct.) Once the stone begins to move, it will proceed until it hits a block. In order to bring the stone to the goal, you may have to stop the stone by hitting it against a block, and throw again.

![](https://cdn.vjudge.net.cn/dfcadffc211686655c382e9ad94bdbfe)

Fig. 1: Example of board (S: start, G: goal)

The movement of the stone obeys the following rules:


    At the beginning, the stone stands still at the start square.
    The movements of the stone are restricted to x and y directions. Diagonal moves are prohibited.
    When the stone stands still, you can make it moving by throwing it. You may throw it to any direction unless it is blocked immediately(Fig. 2(a)).
    Once thrown, the stone keeps moving to the same direction until one of the following occurs:
        The stone hits a block (Fig. 2(b), (c)).
            The stone stops at the square next to the block it hit.
            The block disappears.
        The stone gets out of the board.
            The game ends in failure.
        The stone reaches the goal square.
            The stone stops there and the game ends in success.
    You cannot throw the stone more than 10 times in a game. If the stone does not reach the goal in 10 moves, the game ends in failure.

![](https://cdn.vjudge.net.cn/725189cee19b86e1cd2410490b0dadc2)

Fig. 2: Stone movements

Under the rules, we would like to know whether the stone at the start can reach the goal and, if yes, the minimum number of moves required.

With the initial configuration shown in Fig. 1, 4 moves are required to bring the stone from the start to the goal. The route is shown in Fig. 3(a). Notice when the stone reaches the goal, the board configuration has changed as in Fig. 3(b).


![](https://cdn.vjudge.net.cn/c657651fda754a877e0c3a2ce3a06fd7)

Fig. 3: The solution for Fig. D-1 and the final board configuration

### 输入

The input is a sequence of datasets. The end of the input is indicated by a line containing two zeros separated by a space. The number of datasets never exceeds 100.

Each dataset is formatted as follows.

```txt
the width(=w) and the height(=h) of the board
First row of the board
...
h-th row of the board
```

The width and the height of the board satisfy: $2 \leq w \leq 20$, $1 \leq h \leq 20$.

Each line consists of w decimal numbers delimited by a space. The number describes the status of the corresponding square.

```txt
0 vacant square
1 block
2 start position
3 goal position
```

The dataset for Fig. D-1 is as follows:

```txt
6 6
1 0 0 2 1 0
1 1 0 0 0 0
0 0 0 0 0 3
0 0 0 0 0 0
1 0 0 0 0 1
0 1 1 1 1 1
```


### 输出

For each dataset, print a line having a decimal integer indicating the minimum number of moves along a route from the start to the goal. If there are no such routes, print -1 instead. Each line should not have any character other than this number.


### 样例

#### 输入

```txt
2 1
3 2
6 6
1 0 0 2 1 0
1 1 0 0 0 0
0 0 0 0 0 3
0 0 0 0 0 0
1 0 0 0 0 1
0 1 1 1 1 1
6 1
1 1 2 1 1 3
6 1
1 0 2 1 1 3
12 1
2 0 1 1 1 1 1 1 1 1 1 3
13 1
2 0 1 1 1 1 1 1 1 1 1 1 3
0 0
```

#### 输出

```txt
1
4
-1
4
10
-1
```

## 思路

边界 Case 比较多的搜索题，以下是一些必要考虑的条件

1. 冰球可以向上下左右任意方向连续运动(类似象棋里面“车”的走法)，直到撞到障碍物停下来，然后撞到的障碍物会被移除
2. 当冰球与终点处于同一行/列，且冰球与终点之间没有障碍物时，再走一步就能到终点
3. 当冰球朝着没有障碍物的方向前进时，如果不能经过终点，那么就算出界

DFS 的解决思路是

- 递归函数入参：当前坐标 $\mathbf{s}$，终点坐标 $\mathbf{e}$，已经走的步数 $x$
- 递归基线条件：
  - 搜索步骤超过 10 步，当前路径上无可行解，返回 -1
  - 再走一步就是终点，返回 $1+x$
- 递归执行：尝试上下左右移动冰球，直到遇到障碍物/边界
  - 遇到障碍物：判断下移动后的坐标是不是和移动前相同，如果相同说明不是有效的移动。如果是有效的移动，把前进方向碰到的障碍物移除，进行递归搜索。回溯的时候记得把障碍物还原回来
  - 出界：需要根据前进方向判断出界，如果是左右移动，需要判断列坐标是否会小于 0 或者大于 $w$，上下移动就判断行坐标是否会小于 0 或者大于 $h$

## 解答

```cpp
#include <cstdio>
#include <iostream>
#include <vector>
#include <climits>

using namespace std;

struct coordinate
{
    int x, y;
};

class Solution
{
public:
    int solve(vector<vector<int> > &mat, int h, int w, coordinate current, coordinate end, int current_move);
    bool is_reachable(vector<vector<int> > &mat, coordinate current, coordinate end);
    bool is_valid_move(coordinate current, coordinate prev);
    bool is_valid_position(int h, int w, coordinate current, coordinate direction);
    coordinate try_move_left(vector<vector<int> > &mat, coordinate c);
    coordinate try_move_right(vector<vector<int> > &mat, coordinate c);
    coordinate try_move_up(vector<vector<int> > &mat, coordinate c);
    coordinate try_move_down(vector<vector<int> > &mat, coordinate c);
};

int main(int argc, char const *argv[])
{
    int w = 0, h = 0;
    scanf("%d %d", &w, &h);
    while (w > 0 && h > 0)
    {
        vector<vector<int> > mat(h, vector<int>(w));
        coordinate start, end;
        for (int i = 0; i < h; i++)
        {
            for (int j = 0; j < w; j++)
            {
                scanf("%d", &mat[i][j]);
                if (mat[i][j] == 2)
                {
                    start.x = i, start.y = j;
                }
                if (mat[i][j] == 3)
                {
                    end.x = i, end.y = j;
                }
            }
        }
        Solution s = Solution();
        int result = s.solve(mat, h, w, start, end, 0);
        printf("%d\n", result <= 10 ? result : -1);
        scanf("%d %d", &w, &h);
    }
    return 0;
}

bool Solution::is_reachable(vector<vector<int> > &mat, coordinate current, coordinate end)
{
    if (current.x != end.x && current.y != end.y)
    {
        return false;
    }
    // 冰球当前和目的地在同一行或者同一列，且中间无障碍视为可达
    if (current.x == end.x)
    {
        int start_y = min(current.y, end.y);
        int end_y = max(current.y, end.y);
        for (int i = start_y + 1; i < end_y; i++)
        {
            if (mat[current.x][i] == 1)
            {
                return false;
            }
        }
        return true;
    }
    if (current.y == end.y)
    {
        int start_x = min(current.x, end.x);
        int end_x = max(current.x, end.x);
        for (int i = start_x + 1; i < end_x; i++)
        {
            if (mat[i][current.y] == 1)
            {
                return false;
            }
        }
        return true;
    }
    return false;
}

bool Solution::is_valid_move(coordinate current, coordinate prev)
{
    return current.x != prev.x || current.y != prev.y;
}

bool Solution::is_valid_position(int h, int w, coordinate current, coordinate direction)
{
    // 冰球移到边界就是出局了
    if (direction.y == -1 && direction.x == 0)
    {
        return current.y > 0 && current.y < w - 1;
    }
    if (direction.y == 1 && direction.x == 0)
    {
        return current.y > 0 && current.y < w - 1;
    }
    if (direction.x == -1 && direction.y == 0)
    {
        return current.x > 0 && current.x < h - 1;
    }
    if (direction.x == 1 && direction.y == 0)
    {
        return current.x > 0 && current.x < h - 1;
    }
    return false;
}

coordinate Solution::try_move_left(vector<vector<int> > &mat, coordinate c)
{
    while (c.y)
    {
        if (c.y >= 1 && mat[c.x][c.y - 1] == 1)
        {
            // 再往左一步就是障碍物
            break;
        }
        c.y--;
    }
    return c;
}

coordinate Solution::try_move_right(vector<vector<int> > &mat, coordinate c)
{
    while (c.y < mat[0].size() - 1)
    {
        if (c.y <= mat[0].size() - 2 && mat[c.x][c.y + 1] == 1)
        {
            // 再往右一步就是障碍物
            break;
        }
        c.y++;
    }
    return c;
}

coordinate Solution::try_move_up(vector<vector<int> > &mat, coordinate c)
{
    while (c.x)
    {
        if (c.x >= 1 && mat[c.x - 1][c.y] == 1)
        {
            // 再往上一步就是障碍物
            break;
        }
        c.x--;
    }
    return c;
}

coordinate Solution::try_move_down(vector<vector<int> > &mat, coordinate c)
{
    while (c.x < mat.size() - 1)
    {
        if (c.x <= mat.size() - 2 && mat[c.x + 1][c.y] == 1)
        {
            // 再往下一步就是障碍物
            break;
        }
        c.x++;
    }
    return c;
}

int Solution::solve(vector<vector<int> > &mat, int h, int w, coordinate current, coordinate end, int current_move)
{
    // 基线 1：超过 10 步，返回 -1
    if (current_move > 10)
    {
        return -1;
    }
    // 基线 2: 再走一步就是目的地
    if (is_reachable(mat, current, end))
    {
        return current_move + 1;
    }

    int min_result = INT_MAX;
    // 寻找所有可能的移动
    coordinate possible_left = try_move_left(mat, current);
    if (is_valid_move(possible_left, current) && is_valid_position(h, w, possible_left, {0, -1}))

    {
        mat[possible_left.x][possible_left.y - 1] = 0; // 移除障碍物
        int result = solve(mat, h, w, possible_left, end, current_move + 1);
        if (result != -1)
        {
            min_result = min(min_result, result);
        }
        mat[possible_left.x][possible_left.y - 1] = 1; // 恢复障碍物
    }
    coordinate possible_right = try_move_right(mat, current);
    if (is_valid_move(possible_right, current) && is_valid_position(h, w, possible_right, {0, 1}))
    {
        mat[possible_right.x][possible_right.y + 1] = 0; // 移除障碍物
        int result = solve(mat, h, w, possible_right, end, current_move + 1);
        if (result != -1)
        {
            min_result = min(min_result, result);
        }
        mat[possible_right.x][possible_right.y + 1] = 1; // 恢复障碍物
    }
    coordinate possible_up = try_move_up(mat, current);
    if (is_valid_move(possible_up, current) && is_valid_position(h, w, possible_up, {-1, 0}))
    {
        mat[possible_up.x - 1][possible_up.y] = 0; // 移除障碍物
        int result = solve(mat, h, w, possible_up, end, current_move + 1);
        if (result != -1)
        {
            min_result = min(min_result, result);
        }
        mat[possible_up.x - 1][possible_up.y] = 1; // 恢复障碍物
    }
    coordinate possible_down = try_move_down(mat, current);
    if (is_valid_move(possible_down, current) && is_valid_position(h, w, possible_down, {1, 0}))
    {
        mat[possible_down.x + 1][possible_down.y] = 0; // 移除障碍物
        int result = solve(mat, h, w, possible_down, end, current_move + 1);
        if (result != -1)
        {
            min_result = min(min_result, result);
        }
        mat[possible_down.x + 1][possible_down.y] = 1; // 恢复障碍物
    }
    if (min_result == INT_MAX) // 未找到可行解
    {
        return -1;
    }
    else
    {
        return min_result;
    }
    return -1;
}
```
