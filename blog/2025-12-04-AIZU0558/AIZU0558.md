---
title: AIZU0558 题解
description: AIZU0558 题解
slug: AIZU0558 题解
authors:
  - andrew
tags: [ACM, Algorithm, BFS, Search]
hide_table_of_contents: false
---

<!-- truncate -->

## 原题

[奶酪](https://vjudge.net/problem/Aizu-0558)

今年 JOI 镇的奶酪工厂又开始生产奶酪了，老鼠从巢穴中探出了头。JOI 镇按照东西南北方向划分成网格，每个区域要么是巢穴、奶酪工厂、障碍物，要么是空地。老鼠从巢穴出发，访问所有的奶酪工厂，每个工厂吃掉 1 个奶酪。
这个镇上有 $N$ 个奶酪工厂，每个工厂只生产一种奶酪。奶酪的硬度因工厂而异，生产硬度为 1 到 $N$ 的奶酪工厂各有恰好 1 个。
老鼠最初的体力是 1，每吃掉 1 个奶酪，体力就增加 1。但是，老鼠不能吃比自己体力值更硬的奶酪。
老鼠可以在 1 分钟内移动到东西南北相邻的区域，但不能进入障碍物区域。老鼠也可以不吃奶酪直接通过奶酪工厂。请编写程序求出吃完所有奶酪所需的最短时间。吃奶酪所需的时间可以忽略不计。

### 输入

输入有 $H+1$ 行。第 1 行有 3 个整数 $H$、$W$、$N$（$1 \leq H \leq 1000$，1 $\leq W \leq 1000$，$1 \leq N \leq 9$），按此顺序用空格分隔。从第 2 行到第 $H+1$ 行的每一行都写有一个由 $S, 1, 2, \dots, 9, X, .$ 组成的 $W$ 个字符的字符串，表示各区域的状态。将从北数第 $i$ 个、从西数第 $j$ 个区域记为 $(i,j) (1 \leq i \leq H$，$1 \leq j \leq W)$，第 $i+1$ 行的第 $j$ 个字符表示：区域 $(i,j)$ 是巢穴时为 $S$，是障碍物时为 $X$，是空地时为 $.$，是生产硬度为 $1,2,\dots, 9$ 的奶酪的工厂时分别为 $1,2,\dots, 9$。输入保证有 1 个巢穴和各 1 个生产硬度为 $1,2,\dots, 9$ 的奶酪的工厂。其他格子保证是障碍物或空地。保证老鼠能吃到所有奶酪。

### 输出

输出吃完所有奶酪所需的最短时间（分钟），用一个整数表示，输出一行。

### 样例

#### 输入 1

```txt
3 3 1
S..
...
..1
```

#### 输出 1

```txt
4
```

#### 输入 2

```txt
4 5 2
.X..1
....X
.XX.S
.2.X.
```

#### 输出 2

```txt
12
```

#### 输入 3

```txt
10 10 9
.X...X.S.X
6..5X..X1X
...XXXX..X
X..9X...X.
8.X2X..X3X
...XX.X4..
XX....7X..
X..X..XX..
X...X.XX..
..X.......
```

#### 输出 3

```txt
91
```

## 思路

因为有体力限制，老鼠只能按照从 1 到 $N$ 的顺序吃奶酪，所以只需要分段计算从 $S$ 到 1，1 到 2, ……, $N-1$ 到 $N$ 间的最短路径再相加就可以了

## 解答

```cpp
#include <iostream>
#include <vector>
#include <deque>

using namespace std;

struct coordinate
{
    int x, y, step;
};

coordinate move(coordinate current, coordinate direction)
{
    return {current.x + direction.x, current.y + direction.y};
}

bool operator==(const coordinate &a, const coordinate &b)
{
    return a.x == b.x && a.y == b.y;
}

bool is_valid(int h, int w, coordinate c)
{
    return 0 <= c.x && c.x < h && 0 <= c.y && c.y < w;
}

class Solution
{
public:
    int solve(vector<vector<char>> &mat, int h, int w, vector<coordinate> &cheeses);
    int bfs(vector<vector<char>> mat, int h, int w, coordinate start, coordinate end);
};

int main(int argc, char const *argv[])
{
    int h = 0, w = 0, n = 0;
    cin >> h >> w >> n;
    vector<vector<char>> mat(h, vector<char>(w));
    vector<coordinate> cheeses(n + 1);
    for (int i = 0; i < h; i++)
    {
        string s;
        cin >> s;
        for (int j = 0; j < w; j++)
        {
            mat[i][j] = s[j];
            if (mat[i][j] == 'S')
            {
                cheeses[0] = {i, j};
            }
            if (mat[i][j] >= '1' && mat[i][j] <= '0' + n)
            {
                cheeses[mat[i][j] - '0'] = {i, j};
            }
        }
    }
    Solution s;
    cout << s.solve(mat, h, w, cheeses) << endl;
    return 0;
}

int Solution::solve(vector<vector<char>> &mat, int h, int w, vector<coordinate> &cheeses)
{
    int total_step = 0;
    for (int i = 1; i <= cheeses.size() - 1; i++)
    {
        total_step += bfs(mat, h, w, cheeses[i - 1], cheeses[i]);
    }
    return total_step;
}

// 注意这里 mat 需要使用复制传参，防止 BFS 设置走过的地方已经不能走的逻辑在求解前后两轮最短路径的时候互相影响
int Solution::bfs(vector<vector<char>> mat, int h, int w, coordinate start, coordinate end)
{
    coordinate direction[] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
    deque<coordinate> que;
    start.step = 0;
    que.push_back(start);
    while (!que.empty())
    {
        coordinate current = que.front();
        que.pop_front();
        if (current == end)
        {
            return current.step;
        }
        for (int i = 0; i < 4; i++)
        {
            coordinate next = move(current, direction[i]);
            if (is_valid(h, w, next) && mat[next.x][next.y] != 'X')
            {
                mat[next.x][next.y] = 'X'; // 防止 BFS 回头，也是导致复制传参 mat 的关键
                next.step = current.step + 1;
                que.push_back(next);
            }
        }
    }
    return -1; // 根据题意这个逻辑不可能被执行到
}
```
