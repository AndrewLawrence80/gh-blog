---
title: AIZU0033 Ball 题解
description: AIZU0033 Ball 题解
slug: AIZU0033 Ball 题解
authors:
  - andrew
tags: [ACM, Algorithm, Greedy, Search]
hide_table_of_contents: false
---

<!-- truncate -->

## 原题

Ball

如图所示，有一个分叉的容器。我们将 1 到 10 编号的 10 个球从开口 A 放入容器，将它们放入左边的管子 B 或右边的管子 C 中。板 D 可以围绕支点 E 左右旋转，因此可以通过移动板 D 来决定将球放入管子 B 还是管子 C。
给定从开口 A 放入的球的顺序。我们将它们依次放入管子 B 或管子 C 中。此时，请编写一个程序，如果管子 B 和管子 C 都能做到将编号大的球放在编号小的球上面，则输出 YES；如果不能，则输出 NO。请注意，容器中球的顺序不能改变。此外，可以连续将球放入同一个管子中，并且管子 B 和 C 都有足够的空间容纳所有 10 个球。

![](https://cdn.vjudge.net.cn/c6d8117e2949747585c1dc2953fadf7a)

### 输入

将提供多个数据集。第一行给出数据集的数量 N。接下来是 N 行数据集。每个数据集包含 10 个编号，从左到右以空格分隔。

### 输出

对于每个数据集，输出 YES 或 NO，每行一个。


### 样例

#### 输入

```txt
2
3 1 4 2 5 6 7 8 9 10
10 9 8 7 6 5 4 3 2 1
```

#### 输出

```txt
YES
NO
```

## 思路

### 贪心

题目的要求就是将输入的 10 个数字分成 2 个上升序列，每个序列的数字顺序和输入一致。
如果顺序处理输入的话，可以认为是在两个数轴上标点的过程，并要求任何一个数轴上标的下一个点的坐标 $x_i$ 都要比之前的坐标 $x_{i-1}$ 要大。
考虑第一组样例输入，如果两条数轴上已经分别标了 3 和 1，那么接下来的数字 4 如果标在 1 后面，那么 2 就无法处理，所以 4 必定标在 3 的后面。
因此这里可以采用局部最优的策略：每个需要标定的坐标 $x_i$，寻找两条数轴上已标定坐标的最大值 $\mathbf{X}_{max}$，如果 $\mathbf{X}_{max} < x_i$，将 $x_i$ 标在 $\mathbf{X}_{max}$ 所处数轴上。也就是将 $x_i$ 标在“距离 $x_i$”最近的值的数轴上

### 搜索

就是暴力 DFS，顺序处理每个输入，每个输入都可以放在 2 个管子的任意一个里面，尝试是否能将球全部放完

## 解答

### 贪心

```cpp
#include <cstdio>
#include <iostream>
#include <vector>

using namespace std;

void solve(vector<int> &nums);

int main(int argc, char const *argv[])
{
    int num_cases = 0;
    cin >> num_cases;
    while (num_cases--)
    {
        vector<int> nums(10);
        for (int i = 0; i < 10; i++)
        {
            cin >> nums[i];
        }
        solve(nums);
    }
    return 0;
}

void solve(vector<int> &nums)
{
    int left_max = 0, right_max = 0;
    bool result = true;
    for (int i = 0; result && i < nums.size(); i++)
    {
        int x = nums[i];
        int distance_to_left = x - left_max;
        int distance_to_right = x - right_max;
        if (max(distance_to_left, distance_to_right) < 0)
        {
            result = false;
            continue;
        }
        if (distance_to_left >= 0 && distance_to_right < 0)
        {
            left_max = x;
        }
        if (distance_to_left < 0 && distance_to_right >= 0)
        {
            right_max = x;
        }
        if (distance_to_left > 0 && distance_to_right > 0)
        {
            if (distance_to_left < distance_to_right)
            {
                left_max = x;
            }
            else
            {
                right_max = x;
            }
        }
    }
    if (result)
    {
        printf("YES\n");
    }
    else
    {
        printf("NO\n");
    }
}
```

### 搜索

```cpp
#include <cstdio>
#include <iostream>
#include <vector>

using namespace std;

class Solution
{
public:
    vector<int> pipe_a;
    vector<int> pipe_b;
    void init();
    bool solve(vector<int> &nums, int current_idx);
};

int main(int argc, char const *argv[])
{
    int num_cases = 0;
    cin >> num_cases;
    while (num_cases--)
    {
        vector<int> nums(10);
        for (int i = 0; i < 10; i++)
        {
            cin >> nums[i];
        }
        Solution s = Solution();
        s.init();
        if (s.solve(nums, 0))
        {
            printf("YES\n");
        }
        else
        {
            printf("NO\n");
        }
    }
    return 0;
}

void Solution::init()
{
    pipe_a = vector<int>(1, 0);
    pipe_b = vector<int>(1, 0);
}

bool Solution::solve(vector<int> &nums, int current_idx)
{
    // 递归基线 1: current_idx 超出 nums.size()，说明所有的球都已放完
    if (current_idx == nums.size())
    {
        return true;
    }

    // 递归基线 2: nums[current_idx] 小于 pipe_a[pipe_a.size() - 1]
    // 且 nums[current_idx] 小于 pipe_b[pipe_b.size() - 1]
    // 说明已经没有候选位置，搜索失败
    if (nums[current_idx] < pipe_a.back() && nums[current_idx] < pipe_b.back())
    {
        return false;
    }

    if (nums[current_idx] > pipe_a.back())
    {
        // 尝试在 pipe_a 放置 nums[current_idx]
        pipe_a.push_back(nums[current_idx]);
        if (solve(nums, current_idx + 1))
        {
            return true;
        }
        pipe_a.pop_back();
    }

    if (nums[current_idx] > pipe_b.back())
    {
        // 尝试在 pipe_b 放置 nums[current_idx]
        pipe_b.push_back(nums[current_idx]);
        if (solve(nums, current_idx + 1))
        {
            return true;
        }
        pipe_b.pop_back();
    }

    return false;
}
```