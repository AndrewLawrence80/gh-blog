---
title: POJ3669 题解
description: POJ3669 题解
slug: POJ3669 题解
authors:
  - andrew
tags: [ACM, Algorithm]
hide_table_of_contents: false
---

<!-- truncate -->

## 原题

[Meteor Shower](https://vjudge.net/problem/POJ-3669)

Bessie hears that an extraordinary meteor shower is coming; reports say that these meteors will crash into earth and destroy anything they hit. Anxious for her safety, she vows to find her way to a safe location (one that is never destroyed by a meteor) . She is currently grazing at the origin in the coordinate plane and wants to move to a new, safer location while avoiding being destroyed by meteors along her way.

The reports say that M meteors $(1 \leq M \leq 50,000)$ will strike, with meteor i will striking point $(X_i, Y_i) (0 \leq X_i \leq 300; 0 \leq Y_i \leq 300)$ at time $T_i (0 \leq T_i  \leq 1,000)$. Each meteor destroys the point that it strikes and also the four rectilinearly adjacent lattice points.

Bessie leaves the origin at time 0 and can travel in the first quadrant and parallel to the axes at the rate of one distance unit per second to any of the (often 4) adjacent rectilinear points that are not yet destroyed by a meteor. She cannot be located on a point at any time greater than or equal to the time it is destroyed.

Determine the minimum time it takes Bessie to get to a safe place.

### 输入

- Line 1: A single integer: $M$
- Lines 2..$M+1$: Line $i+1$ contains three space-separated integers: $X_i$, $Y_i$, and $T_i$

### 输出

- Line 1: The minimum time it takes Bessie to get to a safe place or -1 if it is impossible.

### 样例

#### 输入

```txt
4
0 0 2
2 1 2
1 1 2
0 3 5
```

#### 输出

```txt
5
```

## 思路

有些 Trick 的 BFS 题，如果用模拟的思路解决边走边计算当前位置是否危险会超时

更高效的思路是

1. 获取输入后针对每颗流星计算地图上对应点被砸中的最早时间
2. 从原点出发，计算到达不会被摧毁的点的最短路径

## 解答

```cpp
#include <cstdio>
#include <vector>
#include <deque>
#include <climits>

using namespace std;

// 地图时间稍微大一点
const int MAX_N = 500;
const int MAX_T = 1500;

struct coordinate
{
    int x, y, step;
};

coordinate move(coordinate current, coordinate direction)
{
    return {current.x + direction.x, current.y + direction.y};
}

class Solution
{
public:
    vector<vector<int>> step_mat;
    int solve(vector<vector<int>> &mat, vector<vector<coordinate>> meteors, int max_t);
    void strike(vector<vector<int>> &mat, vector<vector<coordinate>> meteors, int max_t);
    bool is_valid(coordinate &c);
    vector<coordinate> bfs(vector<vector<int>> &mat, coordinate start, int current_t);
};

int main(int argc, char const *argv[])
{
    vector<vector<coordinate>> meteors(MAX_T);
    int m = 0;
    scanf("%d", &m);
    int max_time = 0;
    for (int i = 0; i < m; i++)
    {
        int x = 0, y = 0, t = 0;
        scanf("%d %d %d", &x, &y, &t);
        max_time = max(max_time, t);
        meteors[t].push_back({x, y});
    }
    vector<vector<int>> mat(MAX_N, vector<int>(MAX_N, INT_MAX));
    Solution s;
    printf("%d\n", s.solve(mat, meteors, max_time));
    return 0;
}

bool Solution::is_valid(coordinate &c)
{
    return c.x >= 0 && c.y >= 0;
}

int Solution::solve(vector<vector<int>> &mat, vector<vector<coordinate>> meteors, int max_t)
{
    strike(mat, meteors, max_t);

    // 检查起点是否在时间 0 就被摧毁
    if (mat[0][0] == 0)
    {
        return -1;
    }

    // 如果起点永远不会被摧毁，直接返回 0
    if (mat[0][0] == INT_MAX)
    {
        return 0;
    }

    deque<coordinate> que;
    vector<vector<bool>> visited(MAX_N, vector<bool>(MAX_N, false));
    que.push_back({0, 0, 0});
    visited[0][0] = true; // 标记起点为已访问

    coordinate directions[] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};

    while (!que.empty())
    {
        coordinate current = que.front();
        que.pop_front();

        // 尝试向四个方向移动
        for (int i = 0; i < 4; i++)
        {
            coordinate next = move(current, directions[i]);
            next.step = current.step + 1;

            // 检查是否是有效位置且未访问过
            if (!is_valid(next) || visited[next.x][next.y])
            {
                continue;
            }

            // 检查在到达时间 next.step 时，该位置是否安全
            if (mat[next.x][next.y] > next.step)
            {
                // 如果该位置永远不会被摧毁，找到了安全位置
                if (mat[next.x][next.y] == INT_MAX)
                {
                    return next.step;
                }

                visited[next.x][next.y] = true;
                que.push_back(next);
            }
        }
    }

    return -1; // 找不到安全位置
}

void Solution::strike(vector<vector<int>> &mat, vector<vector<coordinate>> meteors, int max_t)
{
    coordinate directions[] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
    for (int t = 0; t <= max_t; t++)
    {
        for (int i = 0; i < meteors[t].size(); i++)
        {
            coordinate meteor = meteors[t][i];
            // 在 t 时刻该点被砸中，记录最早被砸中的时间
            mat[meteor.x][meteor.y] = min(mat[meteor.x][meteor.y], t);
            for (int j = 0; j < 4; j++)
            {
                // 顺便让周围的点也被砸中
                coordinate next = move(meteor, directions[j]);
                if (is_valid(next))
                {
                    mat[next.x][next.y] = min(mat[next.x][next.y], t);
                }
            }
        }
    }
}
```
